//
// Generated file, do not edit! Created by nedtool 5.0 from Frame.msg.
//

#ifndef __FRAME_M_H
#define __FRAME_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <queue>
typedef struct wmHeader{unsigned char msgType; unsigned char seqNum; unsigned char interfaceID; unsigned char channel; 
						unsigned char status; unsigned char recommendedID; unsigned char ONU_COUNT;} WMHeader;
typedef struct wmPayload{unsigned short ONU_ID; unsigned char responseType; unsigned char occupancy; unsigned char channel; unsigned char SLA;} WMPayload;
    						   
typedef struct emheader{int PLI; int keyIndex; unsigned short portID; bool LF; int Others;} EMHeader; // 8Bytes
typedef struct empayload{int src; int dest; long seqNum; int type; long responseBytes;}EMPayload; // 8Bytes
typedef struct em{EMHeader header; EMPayload payload;char name[100];double timeStamp;} EM; 
typedef struct bwmap{unsigned short AllocID; bool DBRu; bool PLOAMu; short startTime; unsigned short grantSize; bool FWI; short HEC;} BWMAP; //8Bytes
typedef struct ploam{unsigned short ONU_ID; unsigned char Msg_Type_ID; char SeqNo; char Msg_Contents[36]; char MIC[8];} PLOAM;	//48Bytes

typedef std::queue<WMPayload> WMPayload_Array;
typedef std::queue<BWMAP> BWMAP_ARRAY;
typedef std::queue<int> DBRU; 
typedef std::queue<EM> EM_CHUNKS;
typedef std::queue<PLOAM> PLOAM_ARRAY;
// }}

/**
 * Class generated from <tt>Frame.msg:52</tt> by nedtool.
 * <pre>
 * packet GenericFrame
 * {
 *     int src;
 *     int dest;
 *     int type;
 *     long seqNum;
 *     long responseBytes;
 * }
 * </pre>
 */
class GenericFrame : public ::omnetpp::cPacket
{
  protected:
    int src;
    int dest;
    int type;
    long seqNum;
    long responseBytes;

  private:
    void copy(const GenericFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GenericFrame&);

  public:
    GenericFrame(const char *name=nullptr, int kind=0);
    GenericFrame(const GenericFrame& other);
    virtual ~GenericFrame();
    GenericFrame& operator=(const GenericFrame& other);
    virtual GenericFrame *dup() const {return new GenericFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSrc() const;
    virtual void setSrc(int src);
    virtual int getDest() const;
    virtual void setDest(int dest);
    virtual int getType() const;
    virtual void setType(int type);
    virtual long getSeqNum() const;
    virtual void setSeqNum(long seqNum);
    virtual long getResponseBytes() const;
    virtual void setResponseBytes(long responseBytes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GenericFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GenericFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Frame.msg:61</tt> by nedtool.
 * <pre>
 * packet GenericFrameWithWMControl extends GenericFrame
 * {
 *     WMHeader header;
 *     WMPayload_Array payload;
 * }
 * </pre>
 */
class GenericFrameWithWMControl : public ::GenericFrame
{
  protected:
    WMHeader header;
    WMPayload_Array payload;

  private:
    void copy(const GenericFrameWithWMControl& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GenericFrameWithWMControl&);

  public:
    GenericFrameWithWMControl(const char *name=nullptr, int kind=0);
    GenericFrameWithWMControl(const GenericFrameWithWMControl& other);
    virtual ~GenericFrameWithWMControl();
    GenericFrameWithWMControl& operator=(const GenericFrameWithWMControl& other);
    virtual GenericFrameWithWMControl *dup() const {return new GenericFrameWithWMControl(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual WMHeader& getHeader();
    virtual const WMHeader& getHeader() const {return const_cast<GenericFrameWithWMControl*>(this)->getHeader();}
    virtual void setHeader(const WMHeader& header);
    virtual WMPayload_Array& getPayload();
    virtual const WMPayload_Array& getPayload() const {return const_cast<GenericFrameWithWMControl*>(this)->getPayload();}
    virtual void setPayload(const WMPayload_Array& payload);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GenericFrameWithWMControl& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GenericFrameWithWMControl& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Frame.msg:67</tt> by nedtool.
 * <pre>
 * packet GenericFrameWithPHYControl extends GenericFrame
 * {
 *     int command;
 *     int tuningWavelength;
 *     double sleepTime;
 *     double sleepDuration;
 * }
 * </pre>
 */
class GenericFrameWithPHYControl : public ::GenericFrame
{
  protected:
    int command;
    int tuningWavelength;
    double sleepTime;
    double sleepDuration;

  private:
    void copy(const GenericFrameWithPHYControl& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GenericFrameWithPHYControl&);

  public:
    GenericFrameWithPHYControl(const char *name=nullptr, int kind=0);
    GenericFrameWithPHYControl(const GenericFrameWithPHYControl& other);
    virtual ~GenericFrameWithPHYControl();
    GenericFrameWithPHYControl& operator=(const GenericFrameWithPHYControl& other);
    virtual GenericFrameWithPHYControl *dup() const {return new GenericFrameWithPHYControl(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getCommand() const;
    virtual void setCommand(int command);
    virtual int getTuningWavelength() const;
    virtual void setTuningWavelength(int tuningWavelength);
    virtual double getSleepTime() const;
    virtual void setSleepTime(double sleepTime);
    virtual double getSleepDuration() const;
    virtual void setSleepDuration(double sleepDuration);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GenericFrameWithPHYControl& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GenericFrameWithPHYControl& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Frame.msg:75</tt> by nedtool.
 * <pre>
 * packet TC
 * {
 *     int wavelength;
 *     int type;
 *     EM_CHUNKS EMs;
 * }
 * </pre>
 */
class TC : public ::omnetpp::cPacket
{
  protected:
    int wavelength;
    int type;
    EM_CHUNKS EMs;

  private:
    void copy(const TC& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TC&);

  public:
    TC(const char *name=nullptr, int kind=0);
    TC(const TC& other);
    virtual ~TC();
    TC& operator=(const TC& other);
    virtual TC *dup() const {return new TC(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getWavelength() const;
    virtual void setWavelength(int wavelength);
    virtual int getType() const;
    virtual void setType(int type);
    virtual EM_CHUNKS& getEMs();
    virtual const EM_CHUNKS& getEMs() const {return const_cast<TC*>(this)->getEMs();}
    virtual void setEMs(const EM_CHUNKS& EMs);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TC& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TC& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Frame.msg:82</tt> by nedtool.
 * <pre>
 * packet TC_US extends TC
 * {
 *     unsigned int ONU_ID;		// 10bits
 *     unsigned int Ind;			// 9bits
 *     unsigned int HEC;			// 13bits
 *     PLOAM PLOAMu; 				// 48bytes * 1 ONUs;
 *     DBRU DBRu;					// 4bytes * N fragmentations
 * }								// total 4bytes * (N+1) + payload
 * </pre>
 */
class TC_US : public ::TC
{
  protected:
    unsigned int ONU_ID;
    unsigned int Ind;
    unsigned int HEC;
    PLOAM PLOAMu;
    DBRU DBRu;

  private:
    void copy(const TC_US& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TC_US&);

  public:
    TC_US(const char *name=nullptr, int kind=0);
    TC_US(const TC_US& other);
    virtual ~TC_US();
    TC_US& operator=(const TC_US& other);
    virtual TC_US *dup() const {return new TC_US(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getONU_ID() const;
    virtual void setONU_ID(unsigned int ONU_ID);
    virtual unsigned int getInd() const;
    virtual void setInd(unsigned int Ind);
    virtual unsigned int getHEC() const;
    virtual void setHEC(unsigned int HEC);
    virtual PLOAM& getPLOAMu();
    virtual const PLOAM& getPLOAMu() const {return const_cast<TC_US*>(this)->getPLOAMu();}
    virtual void setPLOAMu(const PLOAM& PLOAMu);
    virtual DBRU& getDBRu();
    virtual const DBRU& getDBRu() const {return const_cast<TC_US*>(this)->getDBRu();}
    virtual void setDBRu(const DBRU& DBRu);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TC_US& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TC_US& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>Frame.msg:91</tt> by nedtool.
 * <pre>
 * packet TC_DS extends TC
 * {
 *     unsigned int BWmapLength;	// 11bits
 *     unsigned int PLOAMcount;	// 8bits
 *     unsigned int HEC;			// 13bits
 *     BWMAP_ARRAY BWMAPs;			// 8bytes * N Allocations (ONU : Allocations = 1:1)
 *     PLOAM_ARRAY PLOAMd;  		// 48bytes * P ONUs;
 * }								// total 4bytes * (2N+1) + 48bytes * P ONUs + payload
 * </pre>
 */
class TC_DS : public ::TC
{
  protected:
    unsigned int BWmapLength;
    unsigned int PLOAMcount;
    unsigned int HEC;
    BWMAP_ARRAY BWMAPs;
    PLOAM_ARRAY PLOAMd;

  private:
    void copy(const TC_DS& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TC_DS&);

  public:
    TC_DS(const char *name=nullptr, int kind=0);
    TC_DS(const TC_DS& other);
    virtual ~TC_DS();
    TC_DS& operator=(const TC_DS& other);
    virtual TC_DS *dup() const {return new TC_DS(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getBWmapLength() const;
    virtual void setBWmapLength(unsigned int BWmapLength);
    virtual unsigned int getPLOAMcount() const;
    virtual void setPLOAMcount(unsigned int PLOAMcount);
    virtual unsigned int getHEC() const;
    virtual void setHEC(unsigned int HEC);
    virtual BWMAP_ARRAY& getBWMAPs();
    virtual const BWMAP_ARRAY& getBWMAPs() const {return const_cast<TC_DS*>(this)->getBWMAPs();}
    virtual void setBWMAPs(const BWMAP_ARRAY& BWMAPs);
    virtual PLOAM_ARRAY& getPLOAMd();
    virtual const PLOAM_ARRAY& getPLOAMd() const {return const_cast<TC_DS*>(this)->getPLOAMd();}
    virtual void setPLOAMd(const PLOAM_ARRAY& PLOAMd);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TC_DS& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TC_DS& obj) {obj.parsimUnpack(b);}


#endif // ifndef __FRAME_M_H

